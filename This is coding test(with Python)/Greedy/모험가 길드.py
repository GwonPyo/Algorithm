import sys
input = sys.stdin.readline

# 0 <= 모험가 인원(n) <= 100,000
n = int(input())
# 각 모험가의 공포도
x = list(map(int, input().split()))
# 공포도를 오름차순으로 정렬한다.
x.sort()

# 현재 인덱스를 나타내는 변수(now)
now = 0
# 그룹 개수를 세줄 변수(count)
count = 0
# x[now]는 그룹을 짓지 않은 모험가중 가장 낮은 공포도를 의미한다.
# 그룹을 짓기 위해서는 남은 원소가 x[now]의 값보다 크거나 같아야 한다.
# 남은 원소의 개수 = n(리스트의 원소) - 현재 인덱스
# 또한 now < n도 검사해야 하는데,    
# 아래 코드에서 마지막에 now값에 x[now]를 더해야한다.
# 이때 now 인덱스가 x 배열의 index를 초과하면 오류가 발생하게 되므로 now < n 조건도 추가해주었다.
while now < n:
    if x[now] > n - now:
        break
    # 그룹은 x[now]명으로 구성된다.
    # 따라서 다음에 확인할 인덱스는 now에 x[now]를 더한 값이다.
    now += x[now]
    # 그룹을 만들었으므로 count를 더해준다.
    count += 1
# 결과값을 출력한다.
print(count)

"""
(오답)
풀이 시간: 23분
처음에는 어떻게 풀어야할지 몰라서 감이 잡히지 않았다.
곰곰이 생각해보니 공포도 값을 정렬해서 가장 낮은 공포도를 가진 인원부터 그룹핑해준다면 문제를 해결할 수 있다고 생각했다.
사실 큰 값들을 기준으로 먼저 그룹핑하면 얻는 이득이 없다. 예를 들어, 1 2 2 4가 있다고 하자. 작은 공포도를 기준으로 
그룹핑을하면 2개의 그룹을 만들 수 있지만 큰 값을 기준으로 그룹핑하면 1개 밖에 만들지 못한다. 따라서 작은 공포도를 기준으로
그룹핑하도록 공포도 배열(x)를 sort하고 인덱스 0부터 배열을 탐색하도록 했다. 배열 탐색 방법은 위의 반복문의 주석을 참고하자.
하지만 내가 푼 방식에는 오류가 있다. 1 2 2 2 3으로 공포도가 구성되면 (1), (2, 2), (2, 3)으로 그룹핑을 한다. 책의 풀이는 아래와 같다.
"""

n = int(input())
data = list(map(int, input().split()))
data.sort()

result = 0 # 총 그룹의 수
count = 0 # 현재 그룹에 포함된 모험가의 수

for i in data: # 공포도가 낮은 것부터 하나씩 확인한다.
    count += 1 # 현재 그룹에 해당 모험가를 포함시킨다.
    if count >= i:  # 현재 그룹에 포함된 모험가의 수가 현재 공포도 이상이라면, 그룹을 결성한다.
        result += 1 # 총 그룹의 수를 증가시킨다.
        count = 0  # 현재 그룹에 포함된 모험가의 수를 초기화한다.

print(result) # 총 그룹의 수를 출력한다.

