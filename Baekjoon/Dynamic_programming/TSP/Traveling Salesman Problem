TSP(Traveling Salesman Problem)는 조합 최적화(Combinatorial Optimization) 문제로 전삭학에서 연구된 가장 유명한 문제중 하나다.
총 2가지 방식으로 풀이할 수 있다.
1. 비트마스크 + DP + DFS
2. 완전탐색
백준의 외판원 순회2(10971)에서는 2번의 방식으로 풀어도 문제가 없었다.
왜냐하면 이동할 노드의 수가 적었기 때문이다. (2 ≤ N ≤ 10, 시간 복잡도: O(n!))
하지만 외판원 순회(2098)의 경우 N값이 크기 때문에 해당 방식을 사용하면 시간초과가 발생한다. (2 ≤ N ≤ 16)

그럼 1번 방식이 작동되는 원리를 살펴보자.
먼저 비트마스크는 특정 도시를 방문한 상태를 저장할 때 사용한다.

Ex)
000 -> 3번 도시: x / 2번 도시: x / 1번 도시: x
001 -> 3번 도시: x / 2번 도시: x / 1번 도시: o
011 -> 3번 도시: x / 2번 도시: o / 1번 도시: o
111 -> 3번 도시: o / 2번 도시: o / 1번 도시: o

이번에는 출발 도시를 어디로 설정할지 생각해보자.
사실 모든 도시를 돌아서 다시 출발 도시로 돌아오기 때문에 어떤 도시에서 출발하든 상관이 없다.
예를들어, 1->2->3 / 2->3->1 / 3->1->2 3가지의 경우는 모두 같다.
따라서 출발 도시를 어디로 해야할지는 고려할 필요가 없다. (1번도시를 출발도시로 설정하기로 하자.)

DP는 특정 도시들을 방문한 상태일 때 최소 비용을 저장해 놓고 사용한다.
예를 들어,
1->2->3->5->4
1->3->2->5->4
두 가지 경로를 탐색한다고 하자. 
이때 5->4->1 경로의 최소 비용을 중복해서 구한다.
이미 방문한 도시들과 현재 위치한 도시가 같은 경우에는 최소 비용이 일정하므로, 해당 경로를 다시 구할 필요는 없다.
외판원 순회2처럼 n의 수가 적다면 괜찮지만 n의 크기가 크기 때문에 dp를 사용해 시간을 줄여야 한다.

우리는 최소 비용을 저장하기 위해 2차원 배열을 사용할 것이다.
행과 열은  이미 방문한 도시들의 집합과 현재 있는 도시 번호가 된다.
ex) d[i][j] = 이미 방문한 도시들의 집합이 i이고 현재 있는 도시가 j일때, 방문하지 않은 나머지 도시들을 모두 방문한 뒤 출발 도시로 돌아올 때 드는 최소 비용.
예시를 살펴보자.
1 -> 2: d[00011][2] 갱신
1 -> 2 -> 3: d[00111][3] 갱신
1 -> 2 -> 3 -> 5: d[10111][5] 갱신
1 -> 2 -> 3 -> 5 -> 4: d[11111][4] 갱신
따라서 1->3->2->5->4 case에서는 1->3->2->5 경로를 지나 5에 도착했을 때 d[10111][5]값이 있으므로 더 이상 구할 필요가 없다.

이렇게 1번 도시에서 2, 3, 4, 5 도시로 이동했을 때 각 도시에서 남은 도시들을 지나 다시 출발 도시로 돌아오는 최소 비용들 중 최소인 값이 우리가 구하고자하는 값이 된다.
