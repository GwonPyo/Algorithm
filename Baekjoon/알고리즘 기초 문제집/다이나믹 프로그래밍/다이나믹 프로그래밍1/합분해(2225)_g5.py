# My Solution(72ms)
'''
0부터 n까지의 정수 k개를 더해서 합이 n이 되는 경우의 수를 구해야한다.
아래는 n의 값에 따른 값의 변화를 나타낸 표이다.
  1  2  3  4  5
0 1  1  1  1  1
1 1  2  3  4  5
2 1  3  5  9  13
3 1  4  9  18 31
4 1  5  6  24 55

1. n이 0이 될 수는 없지만, n이 만약 0이라면 k값이 어떤 값이라도 결과는 1이 된다.
2. n이 1인 경우를 살펴보자.[값이 1이므로 뒤가 0혹은 1로 덧셈이 끝나야 한다.]
   k가 1이라면 값은 1이다.(다른 값이 n이여도 동일하다.)
   k가 2인 경우는 이전에 n이 0일 때, k가 1인 값([0][1])에 1을 더하거나 이전 경우([1][1])에서 0을 더하는 경우 밖에 없다.
   k가 3인 경우도 동일하게 n이 0일 때, k가 2인 값([0][1])에 1을 더하거나 이전 경우([1][2])에서 0을 더하는 경우 밖에 없다.
   이후 다른 k값도 동일하게 처리하면 뒤가 0 혹은 1로 끝나는 모든 덧셈식의 개수를 계산할 수 있다.
3. n이 2인 경우를 살펴보자.[값이 2이므로 뒤가 0, 1, 2로 끝나야 한다.]
   k가 1이라면 값은 1이다.
   k가 2인 경우 n이 0일 때 k가 1인 값([0][1])에 2를 더하거나 n이 1일 때 k가 1인 값([1][1])에 1을 더하거나 이전 경우([2][1])에 0을 더하는 경우 밖에 없다.
   이때 [0][1], [1][1]의 값을 더한 값이 [1][2]이다. 따라서 [1][2]와 [2][1]의 값을 더해주면 된다.
   k가 3인 경우 n이 0일 때 k가 2인 값([0][2])에 2를 더하거나 n이 1일 때 k가 2인 값([1][2])에 1을 더하거나 이전 경우([2][2])에 0을 더하는 경우 밖에 없다.
   이때 [0][2], [1][2]의 값을 더한 값이 [1][3]이다. 따라서 [1][3]와 [2][2]의 값을 더해주면 된다.
   다른 k값도 동일하게 처리하면 모든 덧셈식의 개수를 계산할 수 있다.
   
다른 경우도 생각해보면 '임의의 i값에 대해 j개의 정수를 더해 만들 수 있는 덧셈의 개수'는 아래와 같은 점화식을 가진다.
dp[i][j] = dp[i][j-1] + dp[i-1][j]

위 점화식은 맨 처음 인덱스부터 차례대로 값을 갱신해주면 1차원 리스트 형태로도 풀 수 있다. 이때 점화식은 아래와 같다.
dp[j] = dp[j-1] + dp[j] (dp[j]값이 아직 갱신되지 않았으므로 dp[i-1][j]값과 동일하기 때문이다.)
아래 코드는 1차원 리스트로 풀이했다.(단, j가 0일 때는 값을 갱신하면 안된다.)
'''
n, k = map(int, input().split())    # n과 k를 입력받는다. (1 ≤ n, k ≤ 200)
dp = [1 for i in range(k)]          # 위 설명처럼 처음 값은 모두 1로 초기화한다.

for i in range(n):                  # 총 n번 반복해서 1~n까지 덧셈 개수를 갱신한다.
    for j in range(1, k):           # 1~k개의 정수를 더해 만들어지는 덧셈의 개수를 갱신한다.
        dp[j] += dp[j-1]            # 위에서 설명한 점화식을 사용한다.

print(dp[k-1]%1000000000)           # 문제의 조건대로 1,000,000,000으로 나눈 나머지를 결과로 출력한다. 
