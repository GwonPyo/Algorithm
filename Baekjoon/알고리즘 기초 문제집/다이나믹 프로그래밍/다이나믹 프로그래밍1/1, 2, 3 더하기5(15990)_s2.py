# My Solution(224ms)
'''
1, 2, 3 으로 수를 구성해야 하지만 이전에 나왔던 숫자가 연속해서 나올 수 없다.
예를 들어, 2를 만들 때 1+1은 1이 연속해서 나오므로 불가능하다.
이러한 문제는 dp를 이차원 배열을 사용해 풀면 해결가능하다. 해당 문제는 아래와 같은 규칙을 가진다.

  0 1 2
0 0 0 0
1 1 0 0
2 0 1 0
3 1 1 1
4 1 1 1
5 2 2 1

임의의 n이라는 숫자를 만든다고 해보자.
n-1을 만드는 방법을 사용하려면 다음에는 +1을 사용해야 n을 만들 수 있다. 
따라서 n-1을 만드는 방법 중 마지막에 더한 수가 1이 아닌 방법을 제외한 나머지 방법의 원소를 더해주면 dp[n][0]을 갱신할 수 있다.
다른 원소들(dp[n][1], dp[n][2])도 위와 같은 방식으로 n-2, n-3원소들을 이용해 갱신해주면 된다.
아래 코드가 위 내용을 구현한 코드이다.

[주의할 점]
처음에 dp[i][0], dp[i][1], dp[i][2]를 갱신할 때 % 1000000009를 해주지 않고 마지막 출력에서만 수행해 주었는데 시간초과가 발생했다.
이렇게 큰 수가 나오는 경우에는 미리 처리하는 것이 비용을 줄일 수 있다는 사실을 기억하자.
'''
import sys
input = sys.stdin.readline                      

test_datas = []                                         # 각 test_case의 n을 저장하기 위한 리스트다 (아래에서 100,000개를 다 갱신한다면 해당 리스트를 생성할 필요는 없다.)
for _ in range(int(input())):                           # 각 test_case의 n을 입력받는다. 
    test_datas.append(int(input()))

dp = [[0, 0, 0] for _ in range(max(test_datas)+1)]      # dynamic programming에 사용할 dp를 생성한다.(100,000개를 다 갱신하는 방법은 228ms로 수행된다.)
dp[1] = [1, 0, 0]                                       # n이 1인 경우를 갱신한다.
dp[2] = [0, 1, 0]                                       # n이 2인 경우를 갱신한다.
dp[3] = [1, 1, 1]                                       # n이 3인 경우를 갱신한다.

for i in range(4, len(dp)):                             # 모든 dp값을 갱신한다.
    dp[i][0] = (dp[i-1][1] + dp[i-1][2]) % 1000000009
    dp[i][1] = (dp[i-2][0] + dp[i-2][2]) % 1000000009
    dp[i][2] = (dp[i-3][0] + dp[i-3][1]) % 1000000009

for test_data in test_datas:                            # 각 test_case의 n값에 맞는 값을 출력해준다.
    print(sum(dp[test_data])%1000000009)
