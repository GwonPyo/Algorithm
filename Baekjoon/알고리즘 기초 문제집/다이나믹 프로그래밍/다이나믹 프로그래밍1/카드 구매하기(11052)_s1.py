#My Solution(144ms)
'''
아래 코드는 다음과 같은 원리로 작동한다.
1. 카드 1장을 살때: p1만 살 수 있으므로 dp[1]에 p1을 저장한다.
2. 카드 2장을 살때: p2, dp[1]+dp[1]중 최대값을 dp[2]에 저장한다.
3. 카드 3장을 살때: p3, dp[2]+dp[1]중 최대값을 dp[3]에 저장한다.
4. 카드 4장을 살때: p4, dp[3]+dp[1], dp[2]+dp[2] 중 최대값을 dp[3]에 저장한다.

위와 같은 방식으로 작동하면 시간 복잡도는 아래와 같다.
이전 case를 모두 구한 경우 카드 n장을 살때  O(n//2+1)=O(n) 만큼의 비용을 가진다.
우리는 0~n까지 모든 case를 구해야한다. 최악의 경우  n이 1,000인 경우다.
해당 케이스를 계산해보면
(짝수 케이스) 2+3+4+...+501 = 501*502/2 = 125,751
(홀수 케이스) 1+2+3+...+500 = 500*501/2 = 125,250
로 최악의 경우도 약 250,000정도의 연산만 수행하면 된다.
'''
import sys
input = sys.stdin.readline

n = int(input())                            # 1 ≤ N ≤ 1,000
dp = [0]+list(map(int, input().split()))    # 1 ≤ Pi ≤ 10,000

def find_max(n):                            # 각 케이스의 최대값을 dp에 저장해주는 함수다.
    for i in range(1, n//2+1):              # pi가 이미 저장되어 있으므로 n//2번만 반복해주면 된다.
        dp[n] = max(dp[n], dp[i]+dp[n-i])   # 이미 저장되어 있는 값과 계산해야할 값을 비교해 더 큰 값을 dp에 저장한다.

for i in range(n+1):                        # 0~n까지 모든 dp를 갱신한다.(사실 반복은 2에서 부터 시작해도 무방하다.)
    find_max(i)                             

print(dp[n])                                # 최종 결과값을 출력한다. 

# Other Solution(260ms)
'''
원리는 내 코드와 동일하다.
'''
n = int(input())                            # 사야하는 카드의 개수를 입력받는다.
p = [0] + list(map(int,input().split()))    # 각 카드팩의 가격을 입력받는다. 
dp = [0 for _ in range(n+1)]                # dynamic programming을 위한 dp를 생성한다.


for i in range(1,n+1):                      # 1~N까지의 dp값을 갱신하기 위해 1~N까지 반복한다.
    for k in range(1,i+1):                  # 1~i까지 반복하면서 dp에 최대값을 갱신한다.
        dp[i] = max(dp[i], dp[i-k] + p[k])  # 내 코드에서는 해당 부분의 비용을 줄였다. (1~n//2까지만 방문했다.)
print(dp[i])                                # 결과 값을 출력한다.
