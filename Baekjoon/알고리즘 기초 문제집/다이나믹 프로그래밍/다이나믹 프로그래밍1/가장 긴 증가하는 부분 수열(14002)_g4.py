# My Solution(164ms)
'''
'가장 긴 증가하는 부분 수열(11053)'와 비슷한 문제다.
모든 것이 동일하지만 마지막에 가장 긴 수열을 출력해야 한다.(여러 개라면 한 개만 출력하면 된다.)

이를 위해서 가장 긴 증가 수열의 길이 문제와 동일하게 dp를 생성했다.
단, dp 값은 해당 인덱스까지의 가장 긴 수열의 길이와 해당 수열의 원소들을 저장한 리스트로 구성된다.
아래 코드의 주석을 참고하자.
'''
n = int(input())                                    # 1 ≤ N(수열의 크기) ≤ 1,000
datas = list(map(int, input().split()))             # 수열의 원소를 담은 리스트다.
dp = [[0, []] for _ in range(n)]                    # 지금까지 가장 긴 수열의 길이와 이전 수의 인덱스를 저장한 리스트다.

for i in range(n):                                  # 0~n-1까지 모든 인덱스를 탐색한다.
    for j in range(i):                              # 0~i-1까지 i이전의 모든 데이터를 탐색한다.
        if datas[i] > datas[j] and dp[i] < dp[j]:   # i번째 수열값보다 작고, 지금까지 탐색한 수열 길이중 가장 길다면 
            dp[i][0] = dp[j][0]                     # 해당 수열의 길이를 현재 dp값에 저장한다.
            dp[i][1] = dp[j][1][:]                  # 해당 수열의 원소들이 저장된 리스트를 저장한다.(슬라이싱을 사용해야 dp[i][1]을 변경해도 dp[j][1]이 변경되지 않는다.)
    dp[i][0]+=1                                     # dp에 저장된 값들은 '이전'에 가장 긴 수열의 길이와 해당 수열의 원소들을 담은 리스트이다. 따라서 현재 값을 포함해야 한다.
    dp[i][1]+=[datas[i]]                            # 즉, 길이에는 1을 더해줘야 하고, 원소 리스트에는 datas[i]를 추가해야 한다.         
    
result = max(dp)                                    # dp에서 max값을 찾는다.
print(result[0])                                    # 해당 dp의 모든 원소를 출력한다.
print(*result[1])

# Other Soltion(148ms)
'''
나는 dp에 각 인덱스에서 가장긴 수열의 원소를 저장한 리스트를 생성해 가장 긴 수열을 출력했다.
하지만 아래 코드를 사용하면 간단히 O(n)의 시간만으로도 가장 긴 수열을 출력할 수 있다.
'''
n = int(input())                                    # 1 ≤ N(수열의 크기) ≤ 1,000
datas = list(map(int, input().split()))             # 수열의 원소를 담은 리스트다.
dp = [0 for _ in range(n)]                          # 지금까지 가장 긴 수열의 길이를 저장한 리스트다.
for i in range(n):                                  # 0~n-1까지 모든 인덱스를 탐색한다.
    for j in range(i):                              # 0~i-1까지 i이전의 모든 데이터를 탐색한다.
        if datas[i] > datas[j] and dp[i] < dp[j]:   # i번째 수열값보다 작고, 지금까지 탐색한 수열 길이중 가장 길다면 
            dp[i] = dp[j]                           # 해당 수열의 길이를 현재 dp값에 저장한다.
    dp[i] += 1                                      # dp값은 이전 원소값의 값이기 때문에 1을 더해준다.
result = max(dp)                                    # dp값중 가장 큰 값이 가장 긴 수열의 길이가 된다.
print(result)

result_arr = []                                     # 가장 긴 수열의 원소를 저장할 리스트다.
for i in range(n-1, -1, -1):                        # n-1~0까지 모든 인덱스를 탐색한다.
    if dp[i] == result:                             # dp[i]가 result와 같다면 해당 길이의 수열의 가장 끝 원소이다.
        result_arr.append(datas[i])                 # 따라서 해당 값을 result_arr에 추가하고 result에 1을 빼준다.
        result -= 1
print(*result_arr[::-1])                            # 리스트를 거꾸로 출력하면 올바른 값이 출력된다.
