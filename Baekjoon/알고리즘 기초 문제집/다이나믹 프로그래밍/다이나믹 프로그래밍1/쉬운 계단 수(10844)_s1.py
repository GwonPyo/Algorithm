# My Solution(68ms)
'''
2차원 배열을 이용하면 아래와 같은 규칙이 생긴다.
  0 1 2 3 4 5 6 7 8 9
0 0 1 1 1 1 1 1 1 1 1
1 1 2 2 2 2 2 2 2 2 1
2 2 3 4 4 4 4 4 4 3 2
3 5 6 7 8 8 8 8 7 6 3

즉, 해당 규칙을 점화식으로 표현해보면 
dp[n][m] = dp[n-1][m-1] + dp[n-1][m+1]
으로 해당 원소의 대각선에 있는 원소들을 더해주면 된다.
단. 0과 9는 각각 대각선 원소가 하나이므로 해당 원소의 값을 그대로 가져와 주면 된다.
'''

n = int(input())                                # 1 <= n <= 100
dp = [[0 for _ in range(10)] for _ in range(n)] # 위 설명처럼 코드를 구현하기 위한 2차원 리스트인 dp를 생성한다.

for i in range(1, 10):                          # 자릿수가 1인 경우는 미리 갱신해준다.
    dp[0][i] = 1

for i in range(1, n):                           # 2~n 자릿수의 계단수를 모두 갱신해준다.
    dp[i][0] = dp[i-1][1]                       # 인덱스 0과 9를 가진 원소를 먼저 갱신한다.
    dp[i][9] = dp[i-1][8]   
    for j in range(1, 9):                       # 1~8까지의 인덱스를 가진 원소를 갱신한다.
        dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

print(sum(dp[n-1])%1000000000)                  # 답을 출력한다.