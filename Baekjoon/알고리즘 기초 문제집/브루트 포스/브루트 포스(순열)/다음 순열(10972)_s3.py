# My Solution(오답)
n = int(input())                        # 1 ≤ N ≤ 10,000
arr = list(map(int, input().split()))   # 현재 순열을 입력받는다.
descended = list(range(n, 0, -1))       # 1~n까지를 내림차순 정렬한다.

'''
내림차순이 시작되는 지점을 찾고 해당 내림차순에서 가장 작은 값을
내림차순이 시작되기 바로 직전의 원소와 바꿔주면 된다고 생각했다.
하지만 아래와 같은 반례가 존재한다.

(입력) 1 2 4 5 3
(출력) 1 2 3 4 5
(정답) 1 2 5 3 4

즉, 내 방법을 사용해 정답을 맞추려면 
내림차순 부분에서 내림차순이 시작되기 직전의 원소보다 값이 큰 원소를 찾고 바꿔주어야 한다.
그리고 내림차순이었던 부분을 ascending sort해주면 결과가 나온다.
단 큰 값은 해당 원소보다 큰 값중에 가장 작아야 한다.

내 코드에서 작은 값을 찾으려면 descended 리스트의 끝 부분부터 탐색하면서 올라가다가 
내린차순이 시작하기 전 원소의 값보다 큰 값을 찾으면 교체해주면 된다.
'''
def sol():
    global arr
    global descended
    if arr == descended:                            # 내림차순 정렬이 arr과 같다면 더 이상 순열을 만들 수 없다.
        return -1                                   # 따라서 -1을 출력한다.
    for i in range(0, n-1):                         # 우리는 내림차순이 시작되기 직전의 인덱스를 알아야한다. 따라서 0~n-2까지 확인하면 된다.
        descended.remove(arr[i])                    # i번째 원소의 값은 descended에서 제외해야 한다.
        
        if arr[i+1:] == descended:                  # 이후 원소들이 내림차순으로 정렬되어 있다면
            arr[i], arr[-1] = arr[-1], arr[i]       # 해당 원소와 내림차순 중 가장 작은 수를 교환한다.(이 부분이 잘못되었다.)
            arr = arr[:i+1] + sorted(arr[i+1:])     # i번째 까지는 그대로 출력하고 뒷 부분은 오름차순 정렬해준다.
            return 0
if sol() == -1: print(-1)                           
else: print(' '.join(map(str, arr)))

# Other Solution(72ms)
import sys
input = sys.stdin.readline
n = int(input())
s = list(map(int, input().split()))
x = 0
'''
마지막 원소부터 탐색을 시작하고
이전 인덱스의 값이 현재 인덱스의 값보다 작다면 (즉, 내림차순이 시작하기 전 인덱스를 찾아준다면)
x에 i-1을 저장한다. => x를 알게 되면 인덱스 x의 원소보다 1 큰 값을 넣어준고 뒤의 값들은 정렬하면 된다.
만약 처음부터 내림차순으로 모든 것이 정렬되어 있다면, x는 초기화한 값인 0이 되어 아래 반복문을 실행하지 않는다.
'''
for i in range(n - 1, 0, -1):               # 마지막 원소부터 탐색을 시작한다.
    if s[i - 1] < s[i]:                     # 만약 이전 원소보다 크기가 크다면
        x = i - 1                           # x에 이전 인덱스를 저장한다. 내림차순이 시작하기 전 지점을 알았으므로 반복문을 더 이상 진행할 이유는 없다. 
        break                               
for i in range(n - 1, 0, -1):               # 마지막 원소부터 탐색을 시작한다.
    if s[x] < s[i]:                         # 내림차순 정렬이 되어 있기 때문에 s[x]보다 큰 값이 나오면 무조건 s[x]보다 1이 큰 수가 나온다.
        s[x], s[i] = s[i], s[x]             # 두 수를 바꿔준다.
        s = s[:x + 1] + sorted(s[x + 1:])   # 인덱스 x까지는 그대로 사용하고 뒷 부분은 정렬해준다.
        print(*s)                           # 결과를 출력한다.
        exit()                              # 함수를 종료한다.
print(-1)
