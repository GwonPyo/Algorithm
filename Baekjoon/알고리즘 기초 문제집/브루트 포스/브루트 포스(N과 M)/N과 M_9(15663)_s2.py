# My Solution1(시간 초과)
'''
수열의 조건은 아래와 같다.
1. N개의 자연수 중에서 M개를 고른 수열

이전 문제들과 가장 큰 차이점은 '숫자 데이터가 중복될 수 있다.'는 점이다.
즉, 2 4 4 처럼 중복된 숫자가 입력될 수 있다.
처음에는 단순히 모든 결과(result)를 리스트(results)에 저장해서
m개의 숫자를 뽑을 때마다 지금까지 결과를 담은 리스트에(results)가 포함되는지 확인하고 
포함되지 않는다면 결과 출력 후 함수를 종료하고
포함된다면 출력하지 않지 않고 함수를 종료한다.
시간 초과가 발생할 것이라고 생각했고, 역시 시간초과가 발생한다. (최악의 경우 O((8!)!)이기 때문이다.)

이전에 외판원에서 배웠던 비트마스크가 써보고 싶어서 써봤다.
'''
n, m = map(int, input().split())                                # n: 총 숫자의 개수, m: 결과를 구성할 숫자의 개수
data = list(map(int, input().split()))                          # data를 입력받는다.
data.sort()                                                     # 사전순으로 출력하기 위해 정렬한다.
data = list(map(str, data))                                     # 출력에서 시간을 줄이기 위해 str로 변형한다.

results = []
def dfs(visited, count, result):
    if count == m and result not in results:                    # m개의 숫자를 탐색했고 이전에 동일한 순열이 없었다면 (시간 초과의 원인)
        print(result)                                           # 결과를 출력하고 해당 결과를 results에 저장한다.
        results.append(result)                                  
        return
    elif count == m: return                                     # m개의 숫자를 탐색했고 이전과 동일한 순열이 있다면 결과를 출력하지 않고 함수를 종료한다.

    for i in range(n):                                          # 만약 찾아야 할 숫자가 더 있다면 0~n-1번째 원소를 각각 탐색한다. 
        if visited & (1<<i) == 0:                               # 해당 원소를 방문하지 않았다면
            dfs(visited | (1<<i), count+1, result+data[i]+' ')  # 해당 인덱스를 방문처리하고 dfs를 수행한다.

dfs(0, 0, '')

# My Solution2(112ms)
'''
위 코드에서 시간초과를 줄이기 위해서 할 일은 명확하다.
조건을 추가해서 가망이 없는 결과는 미리 종료해야 한다.(= 탐색하지 않아야 한다.)

그래서 내가 생각한 방식은
이전 인덱스의 원소(데이터)와 현제 인덱스의 원소(데이터)가 같다면,
이전 인덱스를 방문하지 않았을 때 현재 인덱스를 방문하면 중복된다는 것이다.
예를 들어보자.

(경우1)
1 5 9 9 9가 있고 m은 3이라고 가정하자.

1. 1 5를 뽑고 1번째 9를 뽑는다. m개를 뽑았으니 결과를 출력한다.
2. 다시 1 5를 뽑은 상태에서 2번째 9를 뽑는다면, 결과가 중복된다. (1번째 9는 미방문)

(경우2)
1 5 9 9 9가 있고 m은 4이라고 가정하자.

1. 1 5를 뽑고 1번째 9를 뽑는다.
2. 1 5 9를 뽑은 상태에서 2번째 9를 뽑고, 결과를 출력한다.
3. 다시 1 5 9를 뽑은 상태에서 3번째 9를 뽑으면, 결과가 중복된다. (2번째 9는 미방문)

위 경우들을 보면 이전 인덱스의 9가 뽑히지 않았을 때 해당 9를 뽑지 않으면 해결된다.
'''
n, m = map(int, input().split())                                # n: 총 숫자의 개수, m: 결과를 구성할 숫자의 개수
data = list(map(int, input().split()))                          # data를 입력받는다.
data.sort()                                                     # 사전순으로 출력하기 위해 정렬한다.
data = list(map(str, data))                                     # 출력에서 시간을 줄이기 위해 str로 변형한다.

visited = [False] * n
result = []
def dfs(count):
    if count == m:                                              # m개의 숫자를 뽑았다면
        print(' '.join(result))                                 # 결과를 출력하고 함수를 종료한다.
        return
    for i in range(n):
        '''
        i > 0 조건을 빼고 0번째 인덱스에 대해서는 따로 수행해도 동일하게 114ms가 소요된다.
        '''
        if i > 0 and data[i-1] == data[i] and not visited[i-1]: # 이전 인덱스의 데이터와 해당 인덱스의 데이터가 같고, 이전 인덱스를 탐색하지 않았다면
            continue                                            # 반복문으로 돌아간다.

        if not visited[i]:                                      # 위 조건에 해당하지 않고, 해당 인덱스를 방문한 적이 없다면
            visited[i] = True                                   # 방문 처리를 해준다.
            result.append(data[i])                              # result에 해당 인덱스의 데이터를 넣어준다.
            dfs(count+1)                                        # dfs를 수행한다.
            visited[i] = False                                  # 해당 인덱스를 넣어서 만들 수 있는 모든 경우를 탐색했으므로 미방문 처리한다.(이후에 방문할 수도 있기 때문이다.)
            result.pop()                                        # result에서 해당 인덱스의 데이터를 빼준다.

dfs(0)

# Other Solution(92ms)
'''
위 코드가 작동은 하지만, 코드가 너무 거슬렸다.
특히 i>0 이라는 조건이 매우 안 좋게 보였다.
그래서 다른 방식을 고민해봤지만 해결하지 못했고, 다른 사람의 코드를 참고해봤다.

중복된 데이터가 있을 때 중복되지 않는 모든 순열을 만드는 방법은,
이전에 사용한 데이터가 현제 인덱스의 데이터와 같지 않으면 된다.
이전 예시를 다시 사용해보자.
1 5 9 9 9가 있고 m은 3인 경우다.
1 5 9를 뽑았다.
이때 직전에 사용한 데이터는 9가 된다.
그런데 다음에 탐색하는 데이터가 또 다시 9다.
즉, 이전에 사용한 데이터와 현재 사용할 데이터가 동일하므로 다시 사용하게 되면 중복이 된다.

그러면 m이 4인 경우를 살펴보자.
1 5 9를 뽑았다.
그리고 2번째 9를 뽑는데, 1번째 9는 방문처리가 되어 있어 다시 사용하지 않는다. 
따라서, 2번째 9를 뽑아 1 5 9 9를 만든다.
이때 3번째 9는 2번째 9를 사용했으므로 사용할 수 없다.

이후 1 5로 다시 돌아오게 되고 다시 2번째 9를 탐색하며, 1번째 9를 이미 탐색했으므로 탐색할 수 없다.
3번째 9도 마찬가지다.
'''
n, m = map(int, input().split())                    # n: 총 숫자의 개수, m: 결과를 구성할 숫자의 개수
data = list(map(int, input().split()))              # data를 입력받는다.
data.sort()                                         # 사전순으로 출력하기 위해 정렬한다.
data = list(map(str, data))                         # 출력에서 시간을 줄이기 위해 str로 변형한다.

visited = [False] * n                               # 방문 여부를 확인할 리스트다.
result = []                                         # 결과를 저장할 리스트다.
def dfs(count):
    if count == m:                                  # m개의 숫자를 뽑았다면
        print(' '.join(result))                     # 결과를 출력하고 함수를 종료한다.
        return

    prev = 0                                        # 이전에 사용한 데이터를 저장할 변수다.
    for i in range(n):                              # 순열이므로 0~n까지 탐색한다.
        if not visited[i] and prev != data[i]:      # 해당 인덱스를 방문한 적이 없고 해당 인덱스의 데이터가 이전에 사용한 데이터가 아니라면
            visited[i] = True                       # 방문 처리를 해주고
            result.append(data[i])                  # 해당 인덱스의 데이터를 result에 넣어준다.
            dfs(count+1)                            # dfs를 수행한다.
            visited[i] = False                      # 이후에도 해당 인덱스를 탐색할 수 있으므로 미방문 처리한다.
            result.pop()                            # 또한 해당 데이터를 뽑았을 때의 경우는 모두 탐색했으므로 result에서 빼준다.
            prev = data[i]                          # 이전에 사용한 데이터를 갱신한다.

dfs(0)

