비트마스크는 알고리즘이라기 보단 테크닉에 가깝다. 
비트는 컴퓨터에서 다루는 최소 단위이며, 정수를 이진수로 표현하고 비트 연산을 통해 문제를 해결해 나가는 기술을 비트마스크라고 한다.

예를 들어 10개의 스위치가 있다고 가정하자. 우리는 이 10개의 스위치의 상태를 표현하고 싶다. 이를 list형태로 표현하면 아래와 같다.
switch_states = [True, False, False, True, True, False, False, False, True, True]

하지만 이는 2진수의 숫자로도 표현할 수 있다. python은 dkvdp 0b를 붙여 이진수 표현이 가능하다.
switch_states = 0b1001100011

이렇게 정수형으로 나타내면 아래와 같은 장점을 가진다.
1. 비트연산을 통한 삽입, 삭제, 조회 등이 간단하다.
2. 더 간결한 코드 작성이 가능하다.
3. 더 빠른 연산이 가능하다.
4. 비트마스크를 이용한 정수 표현으로 다이나믹 프로그래밍이 가능하다.(중요)

비트 연산은 아래와 같은 것들이 있다.

1. AND 연산(&)
대응하는 숫자가 모두 1일 경우 1을 반환한다. 
bin()함수는 정수형 자료형이 들어왔을때 이진수 문자열 형태로 돌려주는 함수다.
bin(0b1010011010 & 0b1101101100)  # 0b1000001000

2. OR 연산(|)
대응하는 숫자중 하나라도 1일 경우 1을 반환한다.
bin(0b1010011010 | 0b1101101100)  # 0b1111111110

3. XOR 연산(^)
대응하는 숫자가 서로 다를 경우 1을 반환한다.
bin(0b1010011010 ^ 0b1101101100)  # 0b111110110

4. SHIFT 연산(>>, <<)
a << b는 a의 비트를 b칸 만큼 왼쪽으로 밀어 내는 것이다.
a >> b는 a의 비트를 b칸 만큼 오른쪽으로 밀어낸다.

bin(0b1000 << 2)  # 0b100000
bin(0b0010 << 2)  # 0b1000
bin(0b1100 >> 2)  # 0b11
bin(0b10 >> 2)    # 0b0

5. NOT 연산(~)
비트 값을 반전시킨다.
bin(~0b0010)      # 컴퓨터는 2의 보수 방식을 쓴다. -2를 만들고 싶다면 +1을 해줘야 한다. 출력은 다르지만 컴퓨터 내에서는 1101로 계산된다.

비트 연산을 응용하면 아래와 같은 기능을 구현할 수 있다.

1. 원소 추가
n번째 수를 추가하고자 할 때
n = 3
print(bin(0b0010 | (1 << n)))    # 0b1010

2. 원소 제거
n번째 수를 제거하고자 할 때
n = 3
print(bin(0b1010 & ~(1 << n))    # 0b10
print(bin(0b11101100 & ~0b1000)) # 0b11100100

3. 원소 조회
n번째 수가 있나 없나 확인 할 때(0이면 없고, 1이상이면 있는 것)
n = 3
print(bin(0b1010 & (1 << n)))    # 0b1000

4. 원소 토클
n번째 수를 켜져 있으면 끄고, 꺼져있으면 켠다.
n = 3
print(bin(0b1010 ^ (1 << n))) # 0b10
